//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//   using 3Dmigoto v1.3.16 on Sun Oct 20 16:14:55 2024
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Input
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Output
cs_5_0
dcl_globalFlags refactoringAllowed
dcl_immediateConstantBuffer { { 1.000000, 0, 0, 0},
                              { 0, 1.000000, 0, 0},
                              { 0, 0, 1.000000, 0},
                              { 0, 0, 0, 1.000000} }
dcl_constantbuffer CB0[66], dynamicIndexed
dcl_resource_buffer (uint,uint,uint,uint) t0
dcl_resource_buffer (float,float,float,float) t1
dcl_uav_typed_buffer (uint,uint,uint,uint) u0
dcl_uav_typed_buffer (sint,sint,sint,sint) u1
dcl_input vThreadIDInGroupFlattened
dcl_input vThreadIDInGroup.x
dcl_input vThreadID.y
dcl_temps 4
dcl_tgsm_structured g0, 4, 128
dcl_tgsm_structured g1, 4, 128
dcl_thread_group 2, 32, 1
ult r0.x, vThreadIDInGroupFlattened.x, l(32)
if_nz r0.x
  ishl r0.x, vThreadIDInGroupFlattened.x, l(2)
  mov r0.y, l(0)
  loop
    ige r0.w, r0.y, l(4)
    breakc_nz r0.w
    iadd r0.w, r0.y, r0.x
    mov r1.x, vThreadIDInGroupFlattened.x
    dp4 r1.y, cb0[r1.x + 32].xyzw, icb[r0.y + 0].xyzw
    store_structured g0.x, r0.w, l(0), r1.y
    ineg r1.y, r0.y
    ult r2.xyz, r0.yyyy, l(1, 2, 3, 0)
    and r3.y, r1.y, r2.y
    iadd r0.yz, r0.yyyy, l(0, 1, -3, 0)
    movc r3.z, r2.y, l(0), r0.z
    ieq r3.w, r2.z, l(0)
    mov r3.x, r2.x
    and r1.xyzw, r3.xyzw, cb0[r1.x + 0].xyzw
    or r1.xy, r1.ywyy, r1.xzxx
    or r0.z, r1.y, r1.x
    store_structured g1.x, r0.w, l(0), r0.z
  endloop
endif
sync_g_t
ld_structured r0.x, l(64), l(0), g1.xxxx
ult r0.x, vThreadID.y, r0.x
movc r0.xy, r0.xxxx, l(0,32,0,0), l(64,96,0,0)
ld_structured r0.y, r0.y, l(0), g1.xxxx
ult r0.y, vThreadID.y, r0.y
movc r0.y, r0.y, l(0), l(32)
iadd r0.x, r0.x, r0.y
iadd r0.y, r0.x, l(16)
ld_structured r0.y, r0.y, l(0), g1.xxxx
ult r0.y, vThreadID.y, r0.y
movc r0.y, r0.y, l(0), l(16)
iadd r0.x, r0.x, r0.y
iadd r0.y, r0.x, l(8)
ld_structured r0.y, r0.y, l(0), g1.xxxx
ult r0.y, vThreadID.y, r0.y
movc r0.y, r0.y, l(0), l(8)
iadd r0.x, r0.x, r0.y
iadd r0.y, r0.x, l(4)
ld_structured r0.y, r0.y, l(0), g1.xxxx
ult r0.y, vThreadID.y, r0.y
movc r0.y, r0.y, l(0), l(4)
iadd r0.x, r0.x, r0.y
iadd r0.y, r0.x, l(2)
ld_structured r0.y, r0.y, l(0), g1.xxxx
ult r0.y, vThreadID.y, r0.y
movc r0.y, r0.y, l(0), l(2)
iadd r0.x, r0.x, r0.y
iadd r0.y, r0.x, l(1)
ld_structured r0.y, r0.y, l(0), g1.xxxx
ult r0.y, vThreadID.y, r0.y
movc r0.y, r0.y, l(0), l(1)
iadd r0.x, r0.x, r0.y
utof r0.y, cb0[65].y
iadd r0.z, r0.x, l(1)
ld_structured r0.z, r0.z, l(0), g1.xxxx
utof r1.y, r0.z
mov r1.x, l(0)
add r0.yz, r0.yyyy, r1.xxyx
ftou r0.yz, r0.yyzy
ld_structured r0.x, r0.x, l(0), g0.xxxx
iadd r0.y, r0.y, vThreadID.y
ult r0.z, r0.y, r0.z
ne r0.w, r0.x, l(0.000000)
and r0.z, r0.w, r0.z
if_nz r0.z
  ld_indexable(buffer)(uint,uint,uint,uint) r0.z, r0.yyyy, t0.yzxw
  mov r0.w, l(0)
  loop
    uge r1.x, r0.w, l(3)
    breakc_nz r1.x
    imad r1.x, l(3), vThreadIDInGroup.x, r0.w
    imad r1.y, l(6), r0.y, r1.x
    ld_indexable(buffer)(float,float,float,float) r1.y, r1.yyyy, t1.yxzw
    mul r1.y, r0.x, r1.y
    dp4 r1.z, cb0[64].xyzw, icb[r0.w + 0].xyzw
    movc r1.z, vThreadIDInGroup.x, cb0[64].w, r1.z
    mul r1.y, r1.z, r1.y
    round_ne r1.y, r1.y
    ftoi r1.y, r1.y
    imad r1.x, l(6), r0.z, r1.x
    atomic_iadd u0, r1.x, r1.y
    iadd r0.w, r0.w, l(1)
  endloop
  if_z vThreadIDInGroup.x
    mul r0.x, r0.x, cb0[65].x
    round_ne r0.x, r0.x
    ftoi r0.x, r0.x
    atomic_iadd u1, r0.y, r0.x
  endif
endif
ret
// Approximately 0 instruction slots used

///////////////////////////////// HLSL Code /////////////////////////////////
// // ---- Created with 3Dmigoto v1.3.16 on Sun Oct 20 16:14:55 2024
// groupshared struct { float val[1]; } g1[128];
// groupshared struct { float val[1]; } g0[128];
// Buffer<float4> t1 : register(t1);
//
// Buffer<uint4> t0 : register(t0);
//
// cbuffer cb0 : register(b0)
// {
//   float4 cb0[66];
// }
//
//
//
//
// // 3Dmigoto declarations
// #define cmp -
// Texture1D<float4> IniParams : register(t120);
// Texture2D<float4> StereoParams : register(t125);
//
//
// void main)
// {
//   const float4 icb[] = { { 1.000000, 0, 0, 0},
//                               { 0, 1.000000, 0, 0},
//                               { 0, 0, 1.000000, 0},
//                               { 0, 0, 0, 1.000000} };
// // Needs manual fix for instruction:
// // unknown dcl_: dcl_uav_typed_buffer (uint,uint,uint,uint) u0
// // Needs manual fix for instruction:
// // unknown dcl_: dcl_uav_typed_buffer (sint,sint,sint,sint) u1
//   float4 r0,r1,r2,r3;
//   uint4 bitmask, uiDest;
//   float4 fDest;
//
// // Needs manual fix for instruction:
// // unknown dcl_: dcl_thread_group 2, 32, 1
//   r0.x = cmp((uint)vThreadIDInGroupFlattened.x < 32);
//   if (r0.x != 0) {
//     r0.x = (uint)vThreadIDInGroupFlattened.x << 2;
//     r0.y = 0;
//     while (true) {
//       r0.w = cmp((int)r0.y >= 4);
//       if (r0.w != 0) break;
//       r0.w = (int)r0.y + (int)r0.x;
//       r1.x = vThreadIDInGroupFlattened.x;
//       r1.y = dot(cb0[r1.x+32].xyzw, icb[r0.y+0].xyzw);
//       g0[r0.w].val[0/4] = r1.y;
//       r1.y = -(int)r0.y;
//       r2.xyz = cmp((uint3)r0.yyy < int3(1,2,3));
//       r3.y = r2.y ? r1.y : 0;
//       r0.yz = (int2)r0.yy + int2(1,-3);
//       r3.z = r2.y ? 0 : r0.z;
//       r3.w = cmp((int)r2.z == 0);
//       r3.x = r2.x;
//       r1.xyzw = r3.xyzw ? cb0[r1.x+0].xyzw : 0;
//       r1.xy = (int2)r1.yw | (int2)r1.xz;
//       r0.z = (int)r1.y | (int)r1.x;
//       g1[r0.w].val[0/4] = r0.z;
//     }
//   }
//   GroupMemoryBarrierWithGroupSync();
//   r0.x = g1[64].val[0/4];
//   r0.x = cmp((uint)vThreadID.y < (uint)r0.x);
//   r0.xy = r0.xx ? float2(0,4.48415509e-44) : float2(64,96);
//   r0.y = g1[r0.y].val[0/4];
//   r0.y = cmp((uint)vThreadID.y < (uint)r0.y);
//   r0.y = r0.y ? 0 : 32;
//   r0.x = (int)r0.x + (int)r0.y;
//   r0.y = (int)r0.x + 16;
//   r0.y = g1[r0.y].val[0/4];
//   r0.y = cmp((uint)vThreadID.y < (uint)r0.y);
//   r0.y = r0.y ? 0 : 16;
//   r0.x = (int)r0.x + (int)r0.y;
//   r0.y = (int)r0.x + 8;
//   r0.y = g1[r0.y].val[0/4];
//   r0.y = cmp((uint)vThreadID.y < (uint)r0.y);
//   r0.y = r0.y ? 0 : 8;
//   r0.x = (int)r0.x + (int)r0.y;
//   r0.y = (int)r0.x + 4;
//   r0.y = g1[r0.y].val[0/4];
//   r0.y = cmp((uint)vThreadID.y < (uint)r0.y);
//   r0.y = r0.y ? 0 : 4;
//   r0.x = (int)r0.x + (int)r0.y;
//   r0.y = (int)r0.x + 2;
//   r0.y = g1[r0.y].val[0/4];
//   r0.y = cmp((uint)vThreadID.y < (uint)r0.y);
//   r0.y = r0.y ? 0 : 2;
//   r0.x = (int)r0.x + (int)r0.y;
//   r0.y = (int)r0.x + 1;
//   r0.y = g1[r0.y].val[0/4];
//   r0.y = cmp((uint)vThreadID.y < (uint)r0.y);
//   r0.y = r0.y ? 0 : 1;
//   r0.x = (int)r0.x + (int)r0.y;
//   r0.y = asuint(cb0[65].y);
//   r0.z = (int)r0.x + 1;
//   r0.z = g1[r0.z].val[0/4];
//   r1.y = (uint)r0.z;
//   r1.x = 0;
//   r0.yz = r1.xy + r0.yy;
//   r0.yz = (uint2)r0.yz;
//   r0.x = g0[r0.x].val[0/4];
//   r0.y = (int)r0.y + (int)vThreadID.y;
//   r0.z = cmp((uint)r0.y < (uint)r0.z);
//   r0.w = cmp(r0.x != 0.000000);
//   r0.z = r0.w ? r0.z : 0;
//   if (r0.z != 0) {
//     r0.z = t0.Load(r0.y).x;
//     r0.w = 0;
//     while (true) {
//       r1.x = cmp((uint)r0.w >= 3);
//       if (r1.x != 0) break;
//       r1.x = mad(3, (int)vThreadIDInGroup.x, (int)r0.w);
//       r1.y = mad(6, (int)r0.y, (int)r1.x);
//       r1.y = t1.Load(r1.y).x;
//       r1.y = r1.y * r0.x;
//       r1.z = dot(cb0[64].xyzw, icb[r0.w+0].xyzw);
//       r1.z = vThreadIDInGroup.x ? cb0[64].w : r1.z;
//       r1.y = r1.y * r1.z;
//       r1.y = round(r1.y);
//       r1.y = (int)r1.y;
//       r1.x = mad(6, (int)r0.z, (int)r1.x);
//       // Needs manual fix for instruction:
//         atomic_iadd u0, r1.x, r1.y
//       InterlockedAdd(dest, value, orig_value);
//       r0.w = (int)r0.w + 1;
//     }
//     if (vThreadIDInGroup.x == 0) {
//       r0.x = cb0[65].x * r0.x;
//       r0.x = round(r0.x);
//       r0.x = (int)r0.x;
//       // Needs manual fix for instruction:
//         atomic_iadd u1, r0.y, r0.x
//       InterlockedAdd(dest, value, orig_value);
//     }
//   }
//   return;
// }
//////////////////////////////// HLSL Errors ////////////////////////////////
// C:\Users\Administrator\Desktop\DBMT\Games\WW1.1\3Dmigoto\ShaderFixes\3222cf3da3006e93-cs_replace.txt(22,10): error X3000: syntax error: unexpected token ')'
/////////////////////////////////////////////////////////////////////////////
